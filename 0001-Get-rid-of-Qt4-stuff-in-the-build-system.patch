From 4087aaa7b72fa456249fcfa7036f4db0af36b579 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lu=C3=ADs=20Pereira?= <luis.artur.pereira@gmail.com>
Date: Wed, 25 Mar 2015 07:52:51 -0700
Subject: [PATCH 1/9] Get rid of Qt4 stuff in the build system

Step 1:
    * Remove the Qt4 from the build system;
    * Remove Qt4 only source files.
---
 CMakeLists.txt               | 211 ++++---------
 cmake/FindLibMagic.cmake     |  23 --
 cmake/qt5xdg-config.cmake.in |   8 +-
 cmake/qtxdg-config.cmake.in  |  53 ----
 cmake/qtxdg_use.cmake        |  42 ---
 qiconfix/qiconloader_p_qt4.h | 216 -------------
 qiconfix/qiconloader_qt4.cpp | 737 -------------------------------------------
 xdgmime.cpp                  | 366 ---------------------
 xdgmime.h                    |  99 ------
 9 files changed, 55 insertions(+), 1700 deletions(-)
 delete mode 100644 cmake/FindLibMagic.cmake
 delete mode 100644 cmake/qtxdg-config.cmake.in
 delete mode 100644 cmake/qtxdg_use.cmake
 delete mode 100644 qiconfix/qiconloader_p_qt4.h
 delete mode 100644 qiconfix/qiconloader_qt4.cpp
 delete mode 100644 xdgmime.cpp
 delete mode 100644 xdgmime.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 95266aa..0c78de3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,24 +1,8 @@
-cmake_minimum_required( VERSION 2.8.5 )
-
+cmake_minimum_required(VERSION 2.8.11)
 project(libqtxdg)
 
-# Support different versions of Qt
-option(USE_QT4 "Build with Qt4." $ENV{USE_QT4})
 option(BUILD_TESTS "Builds tests" OFF)
 
-if (USE_QT4)
-    set(USE_QT5 FALSE)
-else()
-    set(USE_QT5 TRUE)
-endif()
-
-# The Qt4 version can be compiled with libmagic or with QtMimeTypes
-# QtMimeTypes is the preferred way and also the default. libmagic will be
-# dropped in future releases.
-if (NOT USE_QT5)
-    option(USE_QTMIMETYPES "Use QtMimeTypes library" ON)
-endif()
-
 # Standard directories for installation
 include(GNUInstallDirs)
 
@@ -41,73 +25,39 @@ if (CMAKE_COMPILER_IS_GNUCXX OR QTXDG_COMPILER_IS_CLANGCXX)
     set(CMAKE_CXX_FLAGS "-fvisibility=hidden -fvisibility-inlines-hidden -fno-exceptions ${CMAKE_CXX_FLAGS}")
 endif()
 
-find_package(PkgConfig)
-
-if (USE_QT5)
-    cmake_minimum_required(VERSION 2.8.11)
-    find_package(Qt5Widgets REQUIRED QUIET)
-    find_package(Qt5Xml REQUIRED QUIET)
-    find_package(Qt5DBus REQUIRED QUIET)
-    if (BUILD_TESTS)
-        find_package(Qt5Test REQUIRED QUIET)
-    endif()
-
-    # if both Qt4 and Qt5 are installed we must check what version was found
-    if (NOT ${Qt5Core_VERSION_MAJOR} EQUAL 5)
-        message(FATAL_ERROR "Qt was found, but NOT Qt5.")
-    endif()
-
-    set(QTXDGX_LIBRARY_NAME "Qt5Xdg")
-    set(QTXDGX_FILE_NAME "qt5xdg")
-
-    set(QTXDGX_PKG_CONFIG_DESCRIPTION "Qt5Xdg, a Qt5 implementation of XDG standards")
-    set(QTXDGX_PKG_CONFIG_REQUIRES "Qt5Core, Qt5Xml, Qt5Widgets, Qt5DBus")
-
-    include_directories(
-        "${Qt5Widgets_INCLUDE_DIRS}"
-        "${Qt5Gui_PRIVATE_INCLUDE_DIRS}"
-        "${Qt5Xml_INCLUDE_DIRS}"
-    )
-    add_definitions(${Qt5Core_DEFINITIONS})
+find_package(Qt5Widgets REQUIRED QUIET)
+find_package(Qt5Xml REQUIRED QUIET)
+find_package(Qt5DBus REQUIRED QUIET)
+if (BUILD_TESTS)
+    find_package(Qt5Test REQUIRED QUIET)
+endif()
+
+
+set(QTXDGX_LIBRARY_NAME "Qt5Xdg")
+set(QTXDGX_FILE_NAME "qt5xdg")
+
+set(QTXDGX_PKG_CONFIG_DESCRIPTION "Qt5Xdg, a Qt5 implementation of XDG standards")
+set(QTXDGX_PKG_CONFIG_REQUIRES "Qt5Core, Qt5Xml, Qt5Widgets, Qt5DBus")
+
+include_directories(
+    "${Qt5Widgets_INCLUDE_DIRS}"
+    "${Qt5Gui_PRIVATE_INCLUDE_DIRS}"
+    "${Qt5Xml_INCLUDE_DIRS}"
+)
+add_definitions(${Qt5Core_DEFINITIONS})
 #    set(CMAKE_CXX_FLAGS
 #        "${CMAKE_CXX_FLAGS} ${Qt5Widgets_EXECUTABLE_COMPILE_FLAGS}"
 #    )
 
-    # QMimeDatabase and QMimeType are part of Qt5Core
-    # We just use that as an mimetype provider.
-    # An empty MIMETYPES_PROVIDER_LIBRARY means we are using Qt internal
-    # mimetypes support
-    set(MIMETYPES_PROVIDER_LIBRARY "")
-    add_definitions("-DHAVE_QTMIMETYPES")
-
-    set(QTX_LIBRARIES ${Qt5Widgets_LIBRARIES} ${Qt5Xml_LIBRARIES} ${Qt5DBus_LIBRARIES})
-    message(STATUS "Building with Qt ${Qt5Core_VERSION_STRING}")
-else()
-    find_package(Qt4 REQUIRED QtCore QtGui QtXml QtDBus QUIET)
-    if (BUILD_TESTS)
-        find_package(Qt4 REQUIRED QtTest QUIET)
-    endif()
-
-    # if both Qt4 and Qt5 are installed we must check what version was found
-    if (NOT ${QT_VERSION_MAJOR} EQUAL 4)
-        message(FATAL_ERROR "Qt was found, but NOT Qt4")
-    endif()
-
-    set(QTXDGX_LIBRARY_NAME "qtxdg")
-    set(QTXDGX_FILE_NAME "qtxdg")
-
-    set(QTXDGX_PKG_CONFIG_DESCRIPTION "QtXdg, a Qt4 implementation of XDG standards")
-
-    include(${QT_USE_FILE})
-    set(QTX_LIBRARIES
-        ${QT_QTCORE_LIBRARY}
-        ${QT_QTGUI_LIBRARY}
-        ${QT_QTXML_LIBRARY}
-        ${QT_QTDBUS_LIBRARY}
-    )
-    message(STATUS "Building with Qt ${QTVERSION}")
-endif()
+# QMimeDatabase and QMimeType are part of Qt5Core
+# We just use that as an mimetype provider.
+# An empty MIMETYPES_PROVIDER_LIBRARY means we are using Qt internal
+# mimetypes support
+set(MIMETYPES_PROVIDER_LIBRARY "")
+add_definitions("-DHAVE_QTMIMETYPES")
 
+set(QTX_LIBRARIES ${Qt5Widgets_LIBRARIES} ${Qt5Xml_LIBRARIES} ${Qt5DBus_LIBRARIES})
+message(STATUS "Building with Qt ${Qt5Core_VERSION_STRING}")
 
 set(libqtxdg_PUBLIC_H_FILES
     xdgaction.h
@@ -119,6 +69,7 @@ set(libqtxdg_PUBLIC_H_FILES
     xmlhelper.h
     xdgautostart.h
     xdgmacros.h
+    xdgmimetype.h
 )
 
 set(libqtxdg_PUBLIC_CLASSES
@@ -130,6 +81,7 @@ set(libqtxdg_PUBLIC_CLASSES
     XdgMenuWidget
     XmlHelper
     XdgAutoStart
+    XdgMimeType
 )
 
 set(libqtxdg_PRIVATE_H_FILES
@@ -154,6 +106,8 @@ set(libqtxdg_CPP_FILES
     xdgmenuwidget.cpp
     xmlhelper.cpp
     xdgautostart.cpp
+    xdgmimetype.cpp
+    qiconfix/qiconloader.cpp
 )
 
 set(libqtxdg_MOCS
@@ -166,44 +120,9 @@ set(libqtxdg_MOCS
     xdgmenuwidget.h
 )
 
-if (USE_QT5)
-    list(APPEND libqtxdg_PRIVATE_INSTALLABLE_H_FILES qiconfix/qiconloader_p.h)
-    list(APPEND libqtxdg_CPP_FILES qiconfix/qiconloader.cpp)
-else()
-    list(APPEND libqtxdg_PRIVATE_H_FILES qiconfix/qiconloader_p_qt4.h)
-    list(APPEND libqtxdg_CPP_FILES qiconfix/qiconloader_qt4.cpp)
-endif()
-
-if (NOT USE_QT5)
-    if (USE_QTMIMETYPES)
-        # Using QtMimeTypes to provide a better mimetype support on Qt4
-        # Project repo: https://qt.gitorious.org/qtplayground/mimetypes
-        pkg_check_modules(QTMIMETYPES REQUIRED
-            QtMimeTypes
-        )
-        include_directories("${QTMIMETYPES_INCLUDE_DIRS}")
-        set(QTXDGX_PKG_CONFIG_REQUIRES "QtCore, QtXml, QtDbus, QtMimeTypes")
-        set(MIMETYPES_PROVIDER_LIBRARY ${QTMIMETYPES_LIBRARIES})
-        link_directories("${QTMIMETYPES_LIBRARY_DIRS}")
-        add_definitions("-DHAVE_QTMIMETYPES")
-    else()
-        # Use libmagic
-        find_package(LibMagic REQUIRED QUIET)
-        set(MIMETYPES_PROVIDER_LIBRARY ${LIBMAGIC_LIBRARY})
-        set(QTXDGX_PKG_CONFIG_REQUIRES "QtCore, QtXml, QtDBus")
-
-        list(APPEND libqtxdg_PUBLIC_H_FILES xdgmime.h)
-        list(APPEND libqtxdg_PUBLIC_CLASSES XdgMime)
-        list(APPEND libqtxdg_CPP_FILES xdgmime.cpp)
-    endif()
-endif()
-
-if (USE_QTMIMETYPES OR USE_QT5)
-    list(APPEND libqtxdg_PUBLIC_H_FILES xdgmimetype.h)
-    list(APPEND libqtxdg_PUBLIC_CLASSES XdgMimeType)
-    list(APPEND libqtxdg_CPP_FILES xdgmimetype.cpp)
-endif()
-
+set(libqtxdg_PRIVATE_INSTALLABLE_H_FILES
+    qiconfix/qiconloader_p.h
+)
 
 set(APP_SHARE_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}/lib${QTXDGX_FILE_NAME}")
 add_definitions(-DTRANSLATIONS_DIR=\"${APP_SHARE_DIR}\")
@@ -220,20 +139,12 @@ set(QTXDG_PATCH_VERSION ${PATCH_VERSION})
 # In tree compilation ......................
 set(QTXDG_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR};${CMAKE_CURRENT_BINARY_DIR}")
 
-if (USE_QT5)
-    set(QTXDG_PRIVATE_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/qiconfix")
-    configure_file(
-        "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qt5xdg-config.cmake.in"
-        "${CMAKE_CURRENT_BINARY_DIR}/cmake/${QTXDGX_FILE_NAME}-config.cmake"
-        @ONLY
-    )
-else()
-    configure_file(
-        "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qtxdg-config.cmake.in"
-        "${CMAKE_CURRENT_BINARY_DIR}/cmake/${QTXDGX_FILE_NAME}-config.cmake"
-        @ONLY
-    )
-endif()
+set(QTXDG_PRIVATE_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/qiconfix")
+configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qt5xdg-config.cmake.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/cmake/${QTXDGX_FILE_NAME}-config.cmake"
+    @ONLY
+)
 
 configure_file(
     "${CMAKE_CURRENT_SOURCE_DIR}/cmake/${QTXDGX_FILE_NAME}_use.cmake"
@@ -244,30 +155,18 @@ configure_file(
 # Instalable ...............................
 set(QTXDG_INCLUDE_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}/${QTXDGX_FILE_NAME}")
 
-if (USE_QT5)
-    set(QTXDG_PRIVATE_INCLUDE_DIR "${QTXDG_INCLUDE_DIR}/${QTXDG_VERSION_STRING}")
-    configure_file(
-        "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qt5xdg-config.cmake.in"
-        "${CMAKE_CURRENT_BINARY_DIR}/${QTXDGX_FILE_NAME}-config.cmake"
-        @ONLY
-    )
-else()
-    configure_file(
-        "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qtxdg-config.cmake.in"
-        "${CMAKE_CURRENT_BINARY_DIR}/${QTXDGX_FILE_NAME}-config.cmake"
-        @ONLY
-    )
-endif()
+set(QTXDG_PRIVATE_INCLUDE_DIR "${QTXDG_INCLUDE_DIR}/${QTXDG_VERSION_STRING}")
+configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qt5xdg-config.cmake.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/${QTXDGX_FILE_NAME}-config.cmake"
+    @ONLY
+)
 
 #**********************************************************
 
 include(FindLibSuffix)
 
-if(USE_QT5)
-    QT5_WRAP_CPP(libqtxdg_CXX_FILES ${libqtxdg_MOCS})
-else()
-    QT4_WRAP_CPP(libqtxdg_CXX_FILES ${libqtxdg_MOCS})
-endif()
+QT5_WRAP_CPP(libqtxdg_CXX_FILES ${libqtxdg_MOCS})
 
 
 if (NOT CMAKE_BUILD_TYPE)
@@ -302,13 +201,11 @@ create_portable_headers(libqtxdg_PORTABLE_HEADERS ${libqtxdg_PUBLIC_CLASSES})
 install(TARGETS ${QTXDGX_LIBRARY_NAME} DESTINATION "${CMAKE_INSTALL_LIBDIR}")
 install(FILES ${libqtxdg_PUBLIC_H_FILES} DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/${QTXDGX_FILE_NAME}")
 
-if (USE_QT5)
-    install(FILES
-            ${libqtxdg_PRIVATE_INSTALLABLE_H_FILES}
-        DESTINATION
-            "${QTXDG_PRIVATE_INCLUDE_DIR}/private/qtxdg"
-    )
-endif()
+install(FILES
+        ${libqtxdg_PRIVATE_INSTALLABLE_H_FILES}
+    DESTINATION
+        "${QTXDG_PRIVATE_INCLUDE_DIR}/private/qtxdg"
+)
 
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${QTXDGX_FILE_NAME}-config.cmake" DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${QTXDGX_FILE_NAME}")
 install(FILES "${CMAKE_CURRENT_BINARY_DIR}/cmake/${QTXDGX_FILE_NAME}_use.cmake" DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${QTXDGX_FILE_NAME}")
diff --git a/cmake/FindLibMagic.cmake b/cmake/FindLibMagic.cmake
deleted file mode 100644
index 929226f..0000000
--- a/cmake/FindLibMagic.cmake
+++ /dev/null
@@ -1,23 +0,0 @@
-FIND_PATH(LIBMAGIC_INCLUDE_DIR magic.h)
-
-FIND_LIBRARY(LIBMAGIC_LIBRARY NAMES magic) 
-
-IF (LIBMAGIC_INCLUDE_DIR AND LIBMAGIC_LIBRARY)
-    SET(LIBMAGIC_FOUND TRUE)
-ENDIF (LIBMAGIC_INCLUDE_DIR AND LIBMAGIC_LIBRARY)
-
-IF (LIBMAGIC_FOUND)
-    IF (NOT LibMagic_FIND_QUIETLY)
-        MESSAGE(STATUS "Found libmagic: ${LIBMAGIC_LIBRARY}")
-        MESSAGE(STATUS "      includes: ${LIBMAGIC_INCLUDE_DIR}")
-    ENDIF (NOT LibMagic_FIND_QUIETLY)
-ELSE (LIBMAGIC_FOUND)
-    IF (LibMagic_FIND_REQUIRED)
-        MESSAGE(STATUS "")
-        MESSAGE(STATUS "libmagic development package cannot be found. Install it, please")
-        MESSAGE(STATUS "For example in (open)SUSE it's file-devel package")
-        MESSAGE(STATUS "")
-        MESSAGE(FATAL_ERROR "Could not find libmagic")
-    ENDIF (LibMagic_FIND_REQUIRED)
-ENDIF (LIBMAGIC_FOUND)
-
diff --git a/cmake/qt5xdg-config.cmake.in b/cmake/qt5xdg-config.cmake.in
index 1a338f5..33eb0b2 100644
--- a/cmake/qt5xdg-config.cmake.in
+++ b/cmake/qt5xdg-config.cmake.in
@@ -21,12 +21,7 @@
 # QTXDG_QT_LIBRARIES   - The QtXdg Qt dependencies libraries
 #
 # Typical usage:
-#    option(USE_QT5 "Build using Qt5. Default off" OFF)
-#    if (USE_QT5)
-#        find_package(QT5XDG)
-#    else()
-#        find_package(QTXDG)
-#    endif()
+#    find_package(QT5XDG)
 #
 #    include(${QTXDG_USE_FILE})
 #    add_executable(use-qtxdg main.cpp)
@@ -44,7 +39,6 @@ set(QTXDG_LIBRARY_DIRS  "@CMAKE_INSTALL_FULL_LIBDIR@")
 
 set(QTXDG_USE_FILE      "${CMAKE_CURRENT_LIST_DIR}/@QTXDGX_FILE_NAME@_use.cmake")
 set(QTXDG_FOUND 1)
-set(QTXDG_QTMIMETYPES   @USE_QTMIMETYPES@)
 
 set(QTXDG_MAJOR_VERSION @QTXDG_MAJOR_VERSION@)
 set(QTXDG_MINOR_VERSION @QTXDG_MINOR_VERSION@)
diff --git a/cmake/qtxdg-config.cmake.in b/cmake/qtxdg-config.cmake.in
deleted file mode 100644
index 33fa866..0000000
--- a/cmake/qtxdg-config.cmake.in
+++ /dev/null
@@ -1,53 +0,0 @@
-# - Find the QtXdg include and library dirs and define a some macros
-#
-# The module defines the following variables
-#  QTXDG_FOUND         - Set to TRUE if all of the above has been found
-#
-#  QTXDG_INCLUDE_DIR   - The QtXdg include directory
-#
-#  QTXDG_INCLUDE_DIRS  - The QtXdg lib and it's dependencies include directories
-#
-#  QTXDG_LIBRARY_DIRS  - The QtXdg lib and it's dependencies linker search paths
-#
-#  QTXDG_LIBRARY       - The QtXdg library itself
-#  QTXDG_LIBRARIES     - The QtXdg library and all it's dependencies
-#
-#  QTXDG_USE_FILE      - The variable QTXDG_USE_FILE is set which is the path
-#                        to a CMake file that can be included to compile qtxdg
-#                        applications and libraries. It sets up the compilation
-#                        environment for include directories and populates a
-#                        QTXDG_LIBRARIES variable.
-#
-# QTXDG_QT_LIBRARIES   - The QtXdg Qt dependencies libraries
-#
-# Typical usage:
-#    option(USE_QT5 "Build using Qt5. Default off" OFF)
-#    if (USE_QT5)
-#        find_package(QT5XDG)
-#    else()
-#        find_package(QTXDG)
-#    endif()
-#
-#    include(${QTXDG_USE_FILE})
-#    add_executable(use-qtxdg main.cpp)
-#    target_link_libraries(use-qtxdg ${QTXDG_LIBRARIES})
-
-set(QTXDG_INCLUDE_DIR   "@QTXDG_INCLUDE_DIR@")
-set(QTXDG_PRIVATE_INCLUDE_DIR "@QTXDG_PRIVATE_INCLUDE_DIR@")
-set(QTXDG_LIBRARY       @QTXDGX_LIBRARY_NAME@)
-
-set(QTXDG_LIBRARIES     ${QTXDG_LIBRARY})
-set(QTXDG_INCLUDE_DIRS  "${QTXDG_INCLUDE_DIR}")
-
-set(QTXDG_LIBRARY_DIRS  "@CMAKE_INSTALL_FULL_LIBDIR@")
-
-set(QTXDG_USE_FILE      "${CMAKE_CURRENT_LIST_DIR}/@QTXDGX_FILE_NAME@_use.cmake")
-set(QTXDG_FOUND 1)
-set(QTXDG_QTMIMETYPES   @USE_QTMIMETYPES@)
-
-set(QTXDG_MAJOR_VERSION @QTXDG_MAJOR_VERSION@)
-set(QTXDG_MINOR_VERSION @QTXDG_MINOR_VERSION@)
-set(QTXDG_PATCH_VERSION @QTXDG_PATCH_VERSION@)
-set(QTXDG_VERSION @QTXDG_MAJOR_VERSION@.@QTXDG_MINOR_VERSION@.@QTXDG_PATCH_VERSION@)
-
-mark_as_advanced(QTXDG_LIBRARY QTXDG_INCLUDE_DIR)
diff --git a/cmake/qtxdg_use.cmake b/cmake/qtxdg_use.cmake
deleted file mode 100644
index 16d4a6a..0000000
--- a/cmake/qtxdg_use.cmake
+++ /dev/null
@@ -1,42 +0,0 @@
-# - Find the Razor-qt include and library dirs and define a some macros
-#
-
-
-find_package(Qt4 REQUIRED QtCore QtGui QtXml QtDBus QUIET)
-include(${QT_USE_FILE})
-
-set(QTXDG_QT_LIBRARIES
-    ${QT_QTCORE_LIBRARY}
-    ${QT_QTGUI_LIBRARY}
-    ${QT_QTXML_LIBRARY}
-    ${QT_DBUS_LIBRARY}
-)
-
-set(QTXDG_LIBRARIES ${QTXDG_LIBRARY} ${QTXDG_QT_LIBRARIES})
-
-set(QTXDG_INCLUDE_DIRS
-    ${QTXDG_INCLUDE_DIRS}
-    ${QT_QTCORE_INCLUDE_DIR}
-    ${QT_QTGUI_INCLUDE_DIR}
-    ${QT_QTXML_INCLUDE_DIR}
-    ${QT_QTDBUS_INCLUDE_DIR}
-)
-
-set(QTXDG_DEFINITIONS ${QT_DEFINITIONS})
-
-if (QTXDG_QTMIMETYPES)
-    find_package(PkgConfig)
-    pkg_check_modules(QTMIMETYPES REQUIRED
-        QtMimeTypes
-    )
-
-    set(QTXDG_LIBRARIES ${QTXDG_LIBRARY} ${QTMIMETYPES_LIBRARIES})
-    set(QTXDG_LIBRARY_DIRS ${QTXDG_LIBRARY_DIRS} ${QTMIMETYPES_LIBRARY_DIRS})
-    set(QTXDG_DEFINITIONS ${QTXDG_DEFINITIONS} "-DQT_MIMETYPES")
-    include_directories(${QTXDG_INCLUDE_DIR} ${QTMIMETYPES_INCLUDE_DIRS})
-    link_directories(${QTXDG_LIBRARY_DIRS})
-    add_definitions("-DQT_MIMETYPES")
-else()
-    include_directories(${QTXDG_INCLUDE_DIR} ${QTMIMETYPES_INCLUDE_DIRS})
-    link_directories(${QTXDG_LIBRARY_DIRS})
-endif()
diff --git a/qiconfix/qiconloader_p_qt4.h b/qiconfix/qiconloader_p_qt4.h
deleted file mode 100644
index 6147af3..0000000
--- a/qiconfix/qiconloader_p_qt4.h
+++ /dev/null
@@ -1,216 +0,0 @@
-/* BEGIN_COMMON_COPYRIGHT_HEADER
- * (c)LGPL2
- */
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-//END_COMMON_COPYRIGHT_HEADER
-
-/*************************************************************************
- It's fixes the following bugs:
-   * QIcon::fromTheme returns pixmaps that are bigger than requested
-        https://bugreports.qt.nokia.com/browse/QTBUG-17953
-
-   * Qt should honor /usr/share/pixmaps as a valid icon directory on Linux
-        https://bugreports.qt.nokia.com/browse/QTBUG-12874
-
-  *************************************************************************/
-
-#ifndef QDESKTOPICON_P_H
-#define QDESKTOPICON_P_H
-
-#ifndef QT_NO_ICON
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtGui/QIcon>
-#include <QtGui/QIconEngine>
-#include <QtGui/QPixmapCache>
-//#include "qt/qicon_p.h"
-//#include "qt/qfactoryloader_p.h"
-#include <QHash>
-
-namespace QtXdg {
-
-class QIconLoader;
-
-struct QIconDirInfo
-{
-    enum Type { Fixed, Scalable, Threshold };
-    QIconDirInfo(const QString &_path = QString()) :
-            path(_path),
-            size(0),
-            maxSize(0),
-            minSize(0),
-            threshold(0),
-            type(Threshold) {}
-    QString path;
-    short size;
-    short maxSize;
-    short minSize;
-    short threshold;
-    Type type : 4;
-};
-
-class QIconLoaderEngineEntry
- {
-public:
-    virtual ~QIconLoaderEngineEntry() {}
-    virtual QPixmap pixmap(const QSize &size,
-                           QIcon::Mode mode,
-                           QIcon::State state) = 0;
-    QString filename;
-    QIconDirInfo dir;
-    static int count;
-};
-
-struct ScalableEntry : public QIconLoaderEngineEntry
-{
-    QPixmap pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state);
-    QIcon svgIcon;
-};
-
-struct PixmapEntry : public QIconLoaderEngineEntry
-{
-    QPixmap pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state);
-    QPixmap basePixmap;
-};
-
-typedef QList<QIconLoaderEngineEntry*> QThemeIconEntries;
-
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-class QIconLoaderEngineFixed : public QIconEngineV2
-#else
-class QIconLoaderEngineFixed : public QIconEngine
-#endif
-{
-public:
-    QIconLoaderEngineFixed(const QString& iconName = QString());
-    ~QIconLoaderEngineFixed();
-
-    void paint(QPainter *painter, const QRect &rect, QIcon::Mode mode, QIcon::State state);
-    QPixmap pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state);
-    QSize actualSize(const QSize &size, QIcon::Mode mode, QIcon::State state);
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-    QIconEngineV2 *clone() const;
-#else
-    QIconEngine *clone() const;
-#endif
-    bool read(QDataStream &in);
-    bool write(QDataStream &out) const;
-
-private:
-    QString key() const;
-    bool hasIcon() const;
-    void ensureLoaded();
-    void virtual_hook(int id, void *data);
-    QIconLoaderEngineEntry *entryForSize(const QSize &size);
-    QIconLoaderEngineFixed(const QIconLoaderEngineFixed &other);
-    QThemeIconEntries m_entries;
-    QString m_iconName;
-    uint m_key;
-
-    friend class QIconLoader;
-};
-
-class QIconTheme
-{
-public:
-    QIconTheme(const QString &name);
-    QIconTheme() : m_valid(false) {}
-    QStringList parents() { return m_parents; }
-    QList <QIconDirInfo> keyList() { return m_keyList; }
-    QString contentDir() { return m_contentDir; }
-    QStringList contentDirs() { return m_contentDirs; }
-    bool isValid() { return m_valid; }
-
-private:
-    QString m_contentDir;
-    QStringList m_contentDirs;
-    QList <QIconDirInfo> m_keyList;
-    QStringList m_parents;
-    bool m_valid;
-};
-
-class QIconLoader : public QObject
-{
-public:
-    QIconLoader();
-    QThemeIconEntries loadIcon(const QString &iconName) const;
-    uint themeKey() const { return m_themeKey; }
-
-    QString themeName() const { return m_userTheme.isEmpty() ? m_systemTheme : m_userTheme; }
-    void setThemeName(const QString &themeName);
-    QIconTheme theme() { return themeList.value(themeName()); }
-    void setThemeSearchPath(const QStringList &searchPaths);
-    QStringList themeSearchPaths() const;
-    QIconDirInfo dirInfo(int dirindex);
-    static QIconLoader *instance();
-    void updateSystemTheme();
-    void invalidateKey() { m_themeKey++; }
-    void ensureInitialized();
-
-private:
-    QThemeIconEntries findIconHelper(const QString &themeName,
-                                     const QString &iconName,
-                                     QStringList &visited) const;
-    uint m_themeKey;
-    bool m_supportsSvg;
-    bool m_initialized;
-
-    mutable QString m_userTheme;
-    mutable QString m_systemTheme;
-    mutable QStringList m_iconDirs;
-    mutable QHash <QString, QIconTheme> themeList;
-};
-
-} // QtXdg
-
-#endif // QDESKTOPICON_P_H
-
-#endif //QT_NO_ICON
diff --git a/qiconfix/qiconloader_qt4.cpp b/qiconfix/qiconloader_qt4.cpp
deleted file mode 100644
index b508e5f..0000000
--- a/qiconfix/qiconloader_qt4.cpp
+++ /dev/null
@@ -1,737 +0,0 @@
-/* BEGIN_COMMON_COPYRIGHT_HEADER
- * (c)LGPL2
- */
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-//END_COMMON_COPYRIGHT_HEADER
-
-#ifndef QT_NO_ICON
-#include "qiconloader_p_qt4.h"
-
-//#include "qt/qapplication_p.h"
-//#include <qt/qicon_p.h>
-//#include <qt/qguiplatformplugin_p.h>
-
-#include <QtGui/QIconEnginePlugin>
-#include <QtGui/QPixmapCache>
-#include <QtGui/QIconEngine>
-#include <QStyleOption>
-#include <QList>
-#include <QHash>
-#include <QDir>
-#include <QSettings>
-#include <QtGui/QPainter>
-#include <QApplication>
-#include <QLatin1Literal>
-//#ifdef Q_WS_MAC
-//#include <private/qt_cocoa_helpers_mac_p.h>
-//#endif
-
-//#ifdef Q_WS_X11
-//#include "qt/qt_x11_p.h"
-//#endif
-#include <QDebug>
-
-#if QT_VERSION < 0x040700
-#include <limits.h>
-#endif
-
-namespace QtXdg {
-
-Q_GLOBAL_STATIC(QIconLoader, iconLoaderInstance)
-
-/* Theme to use in last resort, if the theme does not have the icon, neither the parents  */
-/*static QString fallbackTheme()
-{
-#ifdef Q_WS_X11
-    if (X11->desktopEnvironment == DE_GNOME) {
-        return QLatin1String("gnome");
-    } else if (X11->desktopEnvironment == DE_KDE) {
-        return X11->desktopVersion >= 4
-            ? QString::fromLatin1("oxygen")
-            : QString::fromLatin1("crystalsvg");
-    } else {
-        return QLatin1String("hicolor");
-    }
-#endif
-    return QString();
-}
-*/
-QIconLoader::QIconLoader() :
-        m_themeKey(1), m_supportsSvg(false), m_initialized(false)
-{
-}
-
-// We lazily initialize the loader to make static icons
-// work. Though we do not officially support this.
-void QIconLoader::ensureInitialized()
-{
-    if (!m_initialized) {
-        m_initialized = true;
-
-        Q_ASSERT(qApp);
-
-        m_systemTheme = QIcon::themeName();
-
-#ifndef QT_NO_LIBRARY
-//        QFactoryLoader iconFactoryLoader(QIconEngineFactoryInterfaceV2_iid,
-//                                         QLatin1String("/iconengines"),
-//                                         Qt::CaseInsensitive);
-//        if (iconFactoryLoader.keys().contains(QLatin1String("svg")))
-            m_supportsSvg = true;
-#endif //QT_NO_LIBRARY
-    }
-}
-
-QIconLoader *QIconLoader::instance()
-{
-   return iconLoaderInstance();
-}
-
-// Queries the system theme and invalidates existing
-// icons if the theme has changed.
-void QIconLoader::updateSystemTheme()
-{
-    // Only change if this is not explicitly set by the user
-    if (m_userTheme.isEmpty()) {
-        QString theme = QIcon::themeName();//qt_guiPlatformPlugin()->systemIconThemeName();
-        //if (theme.isEmpty())
-        //    theme = fallbackTheme();
-        if (theme != m_systemTheme) {
-            m_systemTheme = theme;
-            invalidateKey();
-        }
-    }
-}
-
-void QIconLoader::setThemeName(const QString &themeName)
-{
-    m_userTheme = themeName;
-    invalidateKey();
-}
-
-void QIconLoader::setThemeSearchPath(const QStringList &searchPaths)
-{
-    m_iconDirs = searchPaths;
-    themeList.clear();
-    invalidateKey();
-}
-
-QStringList QIconLoader::themeSearchPaths() const
-{
-    if (m_iconDirs.isEmpty())
-    {
-        m_iconDirs = QIcon::themeSearchPaths();//qt_guiPlatformPlugin()->iconThemeSearchPaths();
-        // Always add resource directory as search path
-        m_iconDirs.append(QLatin1String(":/icons"));
-    }
-    return m_iconDirs;
-}
-
-
-QIconTheme::QIconTheme(const QString &themeName)
-        : m_valid(false)
-{
-
-    QFile themeIndex;
-
-    QList <QIconDirInfo> keyList;
-    QStringList iconDirs = QIcon::themeSearchPaths();
-    for ( int i = 0 ; i < iconDirs.size() ; ++i) {
-        QDir iconDir(iconDirs[i]);
-        QString themeDir = iconDir.path() + QLatin1Char('/') + themeName;
-        themeIndex.setFileName(themeDir + QLatin1String("/index.theme"));
-        if (themeIndex.exists()) {
-            m_contentDir = themeDir;
-            m_valid = true;
-
-            QStringList themeSearchPaths = QIcon::themeSearchPaths();
-            foreach (QString path, themeSearchPaths)
-            {
-                if (!path.startsWith(':') && QFileInfo(path).isDir())
-                    m_contentDirs.append(path + QLatin1Char('/') + themeName);
-            }
-
-            break;
-        }
-    }
-
-
-#ifndef QT_NO_SETTINGS
-    if (themeIndex.exists()) {
-        const QSettings indexReader(themeIndex.fileName(), QSettings::IniFormat);
-        QStringListIterator keyIterator(indexReader.allKeys());
-        while (keyIterator.hasNext()) {
-
-            const QString key = keyIterator.next();
-            if (key.endsWith(QLatin1String("/Size"))) {
-                // Note the QSettings ini-format does not accept
-                // slashes in key names, hence we have to cheat
-                if (int size = indexReader.value(key).toInt()) {
-                    QString directoryKey = key.left(key.size() - 5);
-                    QIconDirInfo dirInfo(directoryKey);
-                    dirInfo.size = size;
-                    QString type = indexReader.value(directoryKey +
-                                                     QLatin1String("/Type")
-                                                     ).toString();
-
-                    if (type == QLatin1String("Fixed"))
-                        dirInfo.type = QIconDirInfo::Fixed;
-                    else if (type == QLatin1String("Scalable"))
-                        dirInfo.type = QIconDirInfo::Scalable;
-                    else
-                        dirInfo.type = QIconDirInfo::Threshold;
-
-                    dirInfo.threshold = indexReader.value(directoryKey +
-                                                        QLatin1String("/Threshold"),
-                                                        2).toInt();
-
-                    dirInfo.minSize = indexReader.value(directoryKey +
-                                                         QLatin1String("/MinSize"),
-                                                         size).toInt();
-
-                    dirInfo.maxSize = indexReader.value(directoryKey +
-                                                        QLatin1String("/MaxSize"),
-                                                        size).toInt();
-                    m_keyList.append(dirInfo);
-                }
-            }
-        }
-
-        // Parent themes provide fallbacks for missing icons
-        m_parents = indexReader.value(
-                QLatin1String("Icon Theme/Inherits")).toStringList();
-
-        // Ensure a default platform fallback for all themes
-        if (m_parents.isEmpty())
-            m_parents.append(QIcon::themeName());//fallbackTheme());
-
-        // Ensure that all themes fall back to hicolor
-        if (!m_parents.contains(QLatin1String("hicolor")))
-            m_parents.append(QLatin1String("hicolor"));
-    }
-#endif //QT_NO_SETTINGS
-}
-
-
-QThemeIconEntries QIconLoader::findIconHelper(const QString &themeName,
-                                 const QString &iconName,
-                                 QStringList &visited) const
-{
-    QThemeIconEntries entries;
-    Q_ASSERT(!themeName.isEmpty());
-
-    QPixmap pixmap;
-
-    // Used to protect against potential recursions
-    visited << themeName;
-
-    QIconTheme theme = themeList.value(themeName);
-    if (!theme.isValid()) {
-        theme = QIconTheme(themeName);
-        if (!theme.isValid())
-            theme = QIconTheme(QIcon::themeName());//fallbackTheme());
-
-        themeList.insert(themeName, theme);
-    }
-
-    QStringList contentDirs = theme.contentDirs();
-    QList<QIconDirInfo> subDirs = theme.keyList();
-
-    const QString svgext(QLatin1String(".svg"));
-    const QString pngext(QLatin1String(".png"));
-    const QString xpmext(QLatin1String(".xpm"));
-
-    // Add all relevant files
-    for (int i = 0; i < subDirs.size() ; ++i)
-    {
-        const QIconDirInfo &dirInfo = subDirs.at(i);
-        QString subdir = dirInfo.path;
-
-        foreach (QString contentDir, contentDirs)
-        {
-            QDir currentDir(contentDir + '/' + subdir);
-
-            if (currentDir.exists(iconName + pngext))
-            {
-                PixmapEntry *iconEntry = new PixmapEntry;
-                iconEntry->dir = dirInfo;
-                iconEntry->filename = currentDir.filePath(iconName + pngext);
-                // Notice we ensure that pixmap entries always come before
-                // scalable to preserve search order afterwards
-                entries.prepend(iconEntry);
-                break;
-            }
-            else if (m_supportsSvg &&
-                     currentDir.exists(iconName + svgext))
-            {
-                ScalableEntry *iconEntry = new ScalableEntry;
-                iconEntry->dir = dirInfo;
-                iconEntry->filename = currentDir.filePath(iconName + svgext);
-                entries.append(iconEntry);
-                break;
-            }
-            else if (currentDir.exists(iconName + xpmext))
-            {
-                PixmapEntry *iconEntry = new PixmapEntry;
-                iconEntry->dir = dirInfo;
-                iconEntry->filename = currentDir.filePath(iconName + xpmext);
-                // Notice we ensure that pixmap entries always come before
-                // scalable to preserve search order afterwards
-                entries.append(iconEntry);
-                break;
-            }
-        }
-    }
-
-    if (entries.isEmpty()) {
-        const QStringList parents = theme.parents();
-        // Search recursively through inherited themes
-        for (int i = 0 ; i < parents.size() ; ++i) {
-
-            const QString parentTheme = parents.at(i).trimmed();
-
-            if (!visited.contains(parentTheme)) // guard against recursion
-                entries = findIconHelper(parentTheme, iconName, visited);
-
-            if (!entries.isEmpty()) // success
-                break;
-        }
-    }
-
-    /*********************************************************************
-    Author: Kaitlin Rupert <kaitlin.rupert@intel.com>
-    Date: Aug 12, 2010
-    Description: Make it so that the QIcon loader honors /usr/share/pixmaps
-                 directory.  This is a valid directory per the Freedesktop.org
-                 icon theme specification.
-    Bug: https://bugreports.qt.nokia.com/browse/QTBUG-12874
-     *********************************************************************/
-#ifdef Q_OS_LINUX
-    /* Freedesktop standard says to look in /usr/share/pixmaps last */
-    if (entries.isEmpty()) {
-        const QString pixmaps(QLatin1String("/usr/share/pixmaps"));
-
-        QDir currentDir(pixmaps);
-        QIconDirInfo dirInfo(pixmaps);
-        if (currentDir.exists(iconName + pngext)) {
-            PixmapEntry *iconEntry = new PixmapEntry;
-            iconEntry->dir = dirInfo;
-            iconEntry->filename = currentDir.filePath(iconName + pngext);
-            // Notice we ensure that pixmap entries always come before
-            // scalable to preserve search order afterwards
-            entries.prepend(iconEntry);
-        } else if (m_supportsSvg &&
-                   currentDir.exists(iconName + svgext)) {
-            ScalableEntry *iconEntry = new ScalableEntry;
-            iconEntry->dir = dirInfo;
-            iconEntry->filename = currentDir.filePath(iconName + svgext);
-            entries.append(iconEntry);
-        } else if (currentDir.exists(iconName + xpmext)) {
-            PixmapEntry *iconEntry = new PixmapEntry;
-            iconEntry->dir = dirInfo;
-            iconEntry->filename = currentDir.filePath(iconName + xpmext);
-            // Notice we ensure that pixmap entries always come before
-            // scalable to preserve search order afterwards
-            entries.append(iconEntry);
-        }
-
-    }
-#endif
-
-    if (entries.isEmpty()) {
-       // Search for unthemed icons in main dir of search paths
-       QStringList themeSearchPaths = QIcon::themeSearchPaths();
-        foreach (QString contentDir, themeSearchPaths)  {
-            QDir currentDir(contentDir);
-
-            if (currentDir.exists(iconName + pngext)) {
-                PixmapEntry *iconEntry = new PixmapEntry;
-                iconEntry->filename = currentDir.filePath(iconName + pngext);
-                // Notice we ensure that pixmap entries always come before
-                // scalable to preserve search order afterwards
-                entries.prepend(iconEntry);
-            } else if (m_supportsSvg &&
-                currentDir.exists(iconName + svgext)) {
-                ScalableEntry *iconEntry = new ScalableEntry;
-                iconEntry->filename = currentDir.filePath(iconName + svgext);
-                entries.append(iconEntry);
-                break;
-            } else if (currentDir.exists(iconName + xpmext)) {
-                PixmapEntry *iconEntry = new PixmapEntry;
-                iconEntry->filename = currentDir.filePath(iconName + xpmext);
-                // Notice we ensure that pixmap entries always come before
-                // scalable to preserve search order afterwards
-                entries.append(iconEntry);
-                break;
-            }
-        }
-    }
-    return entries;
-}
-
-QThemeIconEntries QIconLoader::loadIcon(const QString &name) const
-{
-    if (!themeName().isEmpty()) {
-        QStringList visited;
-        return findIconHelper(themeName(), name, visited);
-    }
-
-    return QThemeIconEntries();
-}
-
-
-// -------- Icon Loader Engine -------- //
-
-
-QIconLoaderEngineFixed::QIconLoaderEngineFixed(const QString& iconName)
-        : m_iconName(iconName), m_key(0)
-{
-}
-
-QIconLoaderEngineFixed::~QIconLoaderEngineFixed()
-{
-    while (!m_entries.isEmpty())
-        delete m_entries.takeLast();
-    Q_ASSERT(m_entries.size() == 0);
-}
-
-QIconLoaderEngineFixed::QIconLoaderEngineFixed(const QIconLoaderEngineFixed &other)
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-        : QIconEngineV2(other),
-#else
-        : QIconEngine(other),
-#endif
-        m_iconName(other.m_iconName),
-        m_key(0)
-{
-}
-
-
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-QIconEngineV2 *QIconLoaderEngineFixed::clone() const
-#else
-QIconEngine *QIconLoaderEngineFixed::clone() const
-#endif
-{
-    return new QIconLoaderEngineFixed(*this);
-}
-
-bool QIconLoaderEngineFixed::read(QDataStream &in) {
-    in >> m_iconName;
-    return true;
-}
-
-bool QIconLoaderEngineFixed::write(QDataStream &out) const
-{
-    out << m_iconName;
-    return true;
-}
-
-bool QIconLoaderEngineFixed::hasIcon() const
-{
-    return !(m_entries.isEmpty());
-}
-
-// Lazily load the icon
-void QIconLoaderEngineFixed::ensureLoaded()
-{
-
-    iconLoaderInstance()->ensureInitialized();
-
-    if (!(iconLoaderInstance()->themeKey() == m_key)) {
-
-        while (!m_entries.isEmpty())
-            delete m_entries.takeLast();
-
-        Q_ASSERT(m_entries.size() == 0);
-        m_entries = iconLoaderInstance()->loadIcon(m_iconName);
-        m_key = iconLoaderInstance()->themeKey();
-    }
-}
-
-void QIconLoaderEngineFixed::paint(QPainter *painter, const QRect &rect,
-                             QIcon::Mode mode, QIcon::State state)
-{
-    QSize pixmapSize = rect.size();
-#if defined(Q_WS_MAC)
-    pixmapSize *= qt_mac_get_scalefactor();
-#endif
-    painter->drawPixmap(rect, pixmap(pixmapSize, mode, state));
-}
-
-/*
- * This algorithm is defined by the freedesktop spec:
- * http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
- */
-static bool directoryMatchesSize(const QIconDirInfo &dir, int iconsize)
-{
-    if (dir.type == QIconDirInfo::Fixed) {
-        return dir.size == iconsize;
-
-    } else if (dir.type == QIconDirInfo::Scalable) {
-        return dir.size <= dir.maxSize &&
-                iconsize >= dir.minSize;
-
-    } else if (dir.type == QIconDirInfo::Threshold) {
-        return iconsize >= dir.size - dir.threshold &&
-                iconsize <= dir.size + dir.threshold;
-    }
-
-    Q_ASSERT(1); // Not a valid value
-    return false;
-}
-
-/*
- * This algorithm is defined by the freedesktop spec:
- * http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
- */
-static int directorySizeDistance(const QIconDirInfo &dir, int iconsize)
-{
-    if (dir.type == QIconDirInfo::Fixed) {
-        return qAbs(dir.size - iconsize);
-
-    } else if (dir.type == QIconDirInfo::Scalable) {
-        if (iconsize < dir.minSize)
-            return dir.minSize - iconsize;
-        else if (iconsize > dir.maxSize)
-            return iconsize - dir.maxSize;
-        else
-            return 0;
-
-    } else if (dir.type == QIconDirInfo::Threshold) {
-        if (iconsize < dir.size - dir.threshold)
-            return dir.minSize - iconsize;
-        else if (iconsize > dir.size + dir.threshold)
-            return iconsize - dir.maxSize;
-        else return 0;
-    }
-
-    Q_ASSERT(1); // Not a valid value
-    return INT_MAX;
-}
-
-QIconLoaderEngineEntry *QIconLoaderEngineFixed::entryForSize(const QSize &size)
-{
-    int iconsize = qMin(size.width(), size.height());
-
-    // Note that m_entries are sorted so that png-files
-    // come first
-
-    // Search for exact matches first
-    for (int i = 0; i < m_entries.count(); ++i) {
-        QIconLoaderEngineEntry *entry = m_entries.at(i);
-        if (directoryMatchesSize(entry->dir, iconsize)) {
-            return entry;
-        }
-    }
-
-    // Find the minimum distance icon
-    int minimalSize = INT_MAX;
-    QIconLoaderEngineEntry *closestMatch = 0;
-    for (int i = 0; i < m_entries.count(); ++i) {
-        QIconLoaderEngineEntry *entry = m_entries.at(i);
-        int distance = directorySizeDistance(entry->dir, iconsize);
-        if (distance < minimalSize) {
-            minimalSize  = distance;
-            closestMatch = entry;
-        }
-    }
-    return closestMatch;
-}
-
-/*
- * Returns the actual icon size. For scalable svg's this is equivalent
- * to the requested size. Otherwise the closest match is returned but
- * we can never return a bigger size than the requested size.
- *
- */
-QSize QIconLoaderEngineFixed::actualSize(const QSize &size, QIcon::Mode mode,
-                                   QIcon::State state)
-{
-    ensureLoaded();
-    QIconLoaderEngineEntry *entry = entryForSize(size);
-    if (entry) {
-        const QIconDirInfo &dir = entry->dir;
-        if (dir.type == QIconDirInfo::Scalable)
-        {
-            return size;
-        }
-        else {
-            if (dir.size == 0)
-            {
-                entry->dir.size = QPixmap(entry->filename).size().width();
-                entry->dir.minSize = dir.size;
-                entry->dir.maxSize = dir.size;
-            }
-            int result = qMin<int>(dir.size, qMin(size.width(), size.height()));
-
-            return QSize(result, result);
-        }
-    }
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-    return QIconEngineV2::actualSize(size, mode, state);
-#else
-    return QIconEngine::actualSize(size, mode, state);
-#endif
-}
-
-QPixmap PixmapEntry::pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state)
-{
-    Q_UNUSED(state);
-
-    // Ensure that basePixmap is lazily initialized before generating the
-    // key, otherwise the cache key is not unique
-    if (basePixmap.isNull())
-        basePixmap.load(filename);
-
-    QSize actualSize = basePixmap.size();
-    if (!actualSize.isNull() && (actualSize.width() > size.width() || actualSize.height() > size.height()))
-        actualSize.scale(size, Qt::KeepAspectRatio);
-
-
-    QString key = QString("$qt_theme_%1%2%3%4%5")
-                    .arg(basePixmap.cacheKey(),     16, 16, QChar('0'))
-                    .arg(mode,                      8,  16, QChar('0'))
-                    .arg(qApp->palette().cacheKey(),16, 16, QChar('0'))
-                    .arg(actualSize.width(),        8,  16, QChar('0'))
-                    .arg(actualSize.height(),       8,  16, QChar('0'));
-
-    QPixmap cachedPixmap;
-    if (QPixmapCache::find(key, &cachedPixmap)) {
-        return cachedPixmap;
-    } else {
-        if (basePixmap.size() != actualSize)
-            basePixmap = basePixmap.scaled(actualSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
-
-        QStyleOption opt(0);
-        opt.palette = qApp->palette();
-        cachedPixmap = qApp->style()->generatedIconPixmap(mode, basePixmap, &opt);
-        QPixmapCache::insert(key, cachedPixmap);
-    }
-    return cachedPixmap;
-}
-
-QPixmap ScalableEntry::pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state)
-{
-    if (svgIcon.isNull())
-        svgIcon = QIcon(filename);
-
-    // Simply reuse svg icon engine
-    return svgIcon.pixmap(size, mode, state);
-}
-
-QPixmap QIconLoaderEngineFixed::pixmap(const QSize &size, QIcon::Mode mode,
-                                 QIcon::State state)
-{
-
-    ensureLoaded();
-
-    QIconLoaderEngineEntry *entry = entryForSize(size);
-
-    if (entry)
-        return entry->pixmap(size, mode, state);
-
-    return QPixmap();
-}
-
-QString QIconLoaderEngineFixed::key() const
-{
-    return QLatin1String("QIconLoaderEngineFixed");
-}
-
-void QIconLoaderEngineFixed::virtual_hook(int id, void *data)
-{
-    ensureLoaded();
-
-    switch (id) {
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-    case QIconEngineV2::AvailableSizesHook:
-#else
-    case QIconEngine::AvailableSizesHook:
-#endif
-        {
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-            QIconEngineV2::AvailableSizesArgument &arg
-                    = *reinterpret_cast<QIconEngineV2::AvailableSizesArgument*>(data);
-#else
-            QIconEngine::AvailableSizesArgument &arg
-                    = *reinterpret_cast<QIconEngine::AvailableSizesArgument*>(data);
-#endif
-            const QList<QIconDirInfo> directoryKey = iconLoaderInstance()->theme().keyList();
-            arg.sizes.clear();
-
-            // Gets all sizes from the DirectoryInfo entries
-            for (int i = 0 ; i < m_entries.size() ; ++i) {
-                int size = m_entries.at(i)->dir.size;
-                arg.sizes.append(QSize(size, size));
-            }
-        }
-        break;
-#if (QT_VERSION >= 0x040700) && (QT_VERSION < 0x050000)
-    case QIconEngineV2::IconNameHook:
-        {
-            QString &name = *reinterpret_cast<QString*>(data);
-            name = m_iconName;
-        }
-        break;
-#elif QT_VERSION > QT_VERSION_CHECK(5,0,0)
-    case QIconEngine::IconNameHook:
-        {
-            QString &name = *reinterpret_cast<QString*>(data);
-            name = m_iconName;
-        }
-        break;
-#else// QT_VERSION > QT_VERSION_CHECK(5,0,0)
-#warning QIconEngineV2::IconNameHook is ignored due Qt version. Upgrade to 4.7.x
-#endif
-    default:
-#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
-        QIconEngineV2::virtual_hook(id, data);
-#else
-        QIconEngine::virtual_hook(id, data);
-#endif
-    }
-}
-
-} // QtXdg
-
-#endif //QT_NO_ICON
diff --git a/xdgmime.cpp b/xdgmime.cpp
deleted file mode 100644
index 520a20c..0000000
--- a/xdgmime.cpp
+++ /dev/null
@@ -1,366 +0,0 @@
-/* BEGIN_COMMON_COPYRIGHT_HEADER
- * (c)LGPL2+
- *
- * Razor - a lightweight, Qt based, desktop toolset
- * http://razor-qt.org
- *
- * Copyright: 2010-2011 Razor team
- * Authors:
- *   Alexander Sokoloff <sokoloff.a@gmail.com>
- *
- * This program or library is free software; you can redistribute it
- * and/or modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
-
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301 USA
- *
- * END_COMMON_COPYRIGHT_HEADER */
-
-
-#include "xdgmime.h"
-#include "xdgicon.h"
-#include "xdgdirs.h"
-
-#include <QFileInfo>
-#include <magic.h>
-#include <QDebug>
-#include <QStringList>
-#include <QMap>
-#include <QDir>
-#include <QFileInfo>
-#include <QFile>
-#include <QDomDocument>
-#include <QDomElement>
-#include <QSharedData>
-
-
-struct XdgMimeData
-{
-public:
-    XdgMimeData(QString media, QString subtype);
-    bool readXml(QIODevice* xml);
-    
-    QString mMedia;
-    QString mSubtype;
-
-    bool mDbLoaded;
-    QString mComment;
-    QMap<QString, QString> mLocalizedComments;
-    QStringList mPatterns;
-    QString mSubClassOf;
-};
-
-
-
-/************************************************
-
- ************************************************/
-XdgMimeInfo::XdgMimeInfo(const QString& mimeType)
-{
-    QString media = mimeType.section('/', 0, 0);
-    QString subtype = mimeType.section('/', 1);
-    mData = new XdgMimeData(media, subtype);
-}
-
-XdgMimeInfo::~XdgMimeInfo()
-{
-    delete mData;
-    mData = 0;
-}
-
-/************************************************
-
- ************************************************/
-QString getFileMimeType(const QFileInfo& fileInfo, bool followSymLinks)
-{
-
-    QString result("application/octet-stream");
-
-    magic_t magicMimePredictor;
-    magicMimePredictor = magic_open(MAGIC_MIME_TYPE); // Open predictor
-    if (!magicMimePredictor) {
-        qWarning() << "libmagic: Unable to initialize magic library";
-        return result;
-    }
-
-
-    if (magic_load(magicMimePredictor, 0)) { // if not 0 - error
-        qWarning() << QString("libmagic: Can't load magic database - %1").arg(magic_error(magicMimePredictor));
-        magic_close(magicMimePredictor); // Close predictor
-        return result;
-    }
-
-    QByteArray ar = fileInfo.absoluteFilePath().toLocal8Bit();
-    if (followSymLinks && fileInfo.isSymLink())
-    {
-        ar = fileInfo.symLinkTarget().toLocal8Bit();
-    }
-    char *file = ar.data();
-
-    // getting mime-type ........................
-    const char *mime;
-    mime = magic_file(magicMimePredictor, file);
-    result = QString(mime);
-
-    // Close predictor ..........................
-    magic_close(magicMimePredictor);
-
-    return result;
-}
-
-
-/************************************************
-
- ************************************************/
-XdgMimeInfo::XdgMimeInfo(const QFileInfo& file, bool followSymLinks)
-{
-    QString mimeType = getFileMimeType(file, followSymLinks);
-    QString media = mimeType.section('/', 0, 0);
-    QString subtype = mimeType.section('/', 1);
-    mData = new XdgMimeData(media, subtype);
-}
-
-
-/************************************************
-
- ************************************************/
-QString XdgMimeInfo::mimeType() const
-{
-    return mData->mMedia + "/" + mData->mSubtype;
-}
-
-
-QString XdgMimeInfo::mediaType() const
-{
-    return mData->mMedia;
-}
-
-
-QString XdgMimeInfo::subType() const
-{
-    return mData->mSubtype;
-}
-
-QString XdgMimeInfo::comment() const
-{
-    return mData->mComment;
-}
-
-QString XdgMimeInfo::localizedComment() const
-{
-    // FIXME
-    return mData->mComment;
-}
-
-QStringList XdgMimeInfo::patterns() const
-{
-    return mData->mPatterns;
-}
-
-/************************************************
-
- ************************************************/
-QString XdgMimeInfo::iconName() const
-{
-    QStringList names;
-    names << QString("%1-x-%2").arg(mData->mMedia, mData->mSubtype);
-    names << QString("%1-%2").arg(mData->mMedia, mData->mSubtype);
-    names << QString("%1-x-generic").arg(mData->mMedia);
-    names << QString("%1-generic").arg(mData->mMedia);
-
-    foreach (QString s, names)
-    {
-        if (!XdgIcon::fromTheme(s).isNull())
-            return s;
-    }
-
-    return "unknown";
-}
-
-/************************************************
-
- ************************************************/
-QIcon XdgMimeInfo::icon() const
-{
-    return XdgIcon::fromTheme(iconName());
-}
-
-
-QString XdgMimeInfo::subClassOf() const
-{
-    return mData->mSubClassOf;
-}
-
-
-bool XdgMimeInfo::loadFromDb(QIODevice* xml)
-{
-    return mData->readXml(xml);
-}
-
-
-
-XdgMimeData::XdgMimeData(QString media, QString subtype): 
-        mMedia(media),
-        mSubtype(subtype),
-        mDbLoaded(false)
-{
-}
-
-bool XdgMimeData::readXml(QIODevice* xml)
-{
-    QDomDocument domDocument;
-    if (! domDocument.setContent(xml, false))
-    {
-        return false;
-    }
-
-    QDomElement rootElement = domDocument.documentElement();
-    if (rootElement.nodeName() != "mime-type")
-    {
-        return false;
-    }
-
-    if (rootElement.attribute("type") != mMedia + "/" + mSubtype)
-    {
-        return false;
-    }
-
-    QDomNodeList commentNodes = rootElement.elementsByTagName("comment");
-    for(int i = 0; i < commentNodes.size(); i++)
-    {
-        if (! commentNodes.item(i).isElement())
-        {
-            continue;
-        }
-
-        QDomElement commentElement = commentNodes.item(i).toElement();
-
-        if (commentElement.hasAttribute("xml:lang"))
-        {
-            mLocalizedComments[commentElement.attribute("xml:lang")] = commentElement.text();
-        }
-        else 
-        {
-            mComment = commentElement.text();
-        }
-    }
-
-    QSet<QString> collectedPatterns; 
-    QDomNodeList globNodes = rootElement.elementsByTagName("glob");
-    for(int i = 0; i < globNodes.size(); i++)
-    {
-        if (globNodes.item(i).isElement() && globNodes.item(i).toElement().hasAttribute("pattern"))
-        {
-            collectedPatterns << globNodes.item(i).toElement().attribute("pattern");
-        }
-    }
-    
-    mPatterns = collectedPatterns.toList();
-    mPatterns.sort();
-
-    QDomNodeList subClassOfElements = rootElement.elementsByTagName("sub-class-of");
-    if (subClassOfElements.size() > 0)
-    {
-        mSubClassOf = subClassOfElements.at(0).toElement().attribute("type");
-    }
-
-    return true;
-}
-
-
-QStringList XdgMimeInfoCache::mediatypes()
-{
-    return cache().keys();
-}
-
-QStringList XdgMimeInfoCache::subtypes(const QString& media)
-{
-    return cache().value(media).keys();
-}
-
-XdgMimeInfo* XdgMimeInfoCache::xdgMimeInfo(const QString & media, const QString & subtype)
-{
-    return cache().value(media).value(subtype);
-}
-
-XdgMimeInfo* XdgMimeInfoCache::xdgMimeInfo(const QString& mimetype)
-{
-    QString media = mimetype.section("/", 0, 0);
-    QString subtype = mimetype.section("/", 1, 1);
-    return xdgMimeInfo(media, subtype);
-}
-
-
-void loadMimeInfoCache(QMap<QString, QMap<QString, XdgMimeInfo*> > & cache)
-{
-    qDebug() << "loadMimeInfoCache";
-    QStringList datadirs = XdgDirs::dataDirs(); 
-    datadirs.prepend(XdgDirs::dataHome(false));
-    const QStringList filters = (QStringList() << "*.xml");
- 
-    foreach (const QString datadir, datadirs)
-    {
-        QDir mimedir(datadir + "/mime");
-        
-        if (! mimedir.exists())
-        {
-            continue;
-        }
-        
-       
-        foreach (QFileInfo mediadirInfo, mimedir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot))
-        {
-            QString media = mediadirInfo.fileName();
-            
-            QDir mediadir(mediadirInfo.absoluteFilePath()); 
-            foreach (QFileInfo subtypefileInfo, mediadir.entryInfoList(filters, QDir::Files))
-            {
-                QString subtype = subtypefileInfo.fileName().left(subtypefileInfo.fileName().length() - 4);
-                //qDebug() << "subtype:" << subtype;
-                QFile subtypefile(subtypefileInfo.absoluteFilePath());
-                XdgMimeInfo* mimeInfo = new XdgMimeInfo(media + "/" + subtype);
-                if (subtypefile.open(QIODevice::ReadOnly) && mimeInfo->loadFromDb(&subtypefile))
-                {
-                    cache[media][subtype] = mimeInfo;
-                }
-                else 
-                {
-                    delete mimeInfo;
-                }
-                
-            }
-        }
-    }
-
-    // TESTING
-    XdgMimeData data("application", "msword");
-    QFile mswordxml("/usr/share/mime/application/msword.xml");
-    mswordxml.open(QIODevice::ReadOnly);
-    data.readXml(&mswordxml);
-    qDebug() << "=================================================================================";
-    qDebug() << "data:" << data.mMedia << data.mSubtype << data.mComment << data.mLocalizedComments << data.mPatterns;
-    qDebug() << "=================================================================================";
-}
-
-QMap<QString, QMap<QString, XdgMimeInfo*> > & XdgMimeInfoCache::cache()
-{
-    static QMap<QString, QMap<QString, XdgMimeInfo*> > _cache;
-    static bool cache_loaded = false;
-
-    if (! cache_loaded)
-    {
-        loadMimeInfoCache(_cache);
-        cache_loaded = true;
-    }
-    
-    return _cache;
-}
diff --git a/xdgmime.h b/xdgmime.h
deleted file mode 100644
index 7c4a201..0000000
--- a/xdgmime.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* BEGIN_COMMON_COPYRIGHT_HEADER
- * (c)LGPL2+
- *
- * Razor - a lightweight, Qt based, desktop toolset
- * http://razor-qt.org
- *
- * Copyright: 2010-2011 Razor team
- * Authors:
- *   Alexander Sokoloff <sokoloff.a@gmail.com>
- *
- * This program or library is free software; you can redistribute it
- * and/or modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
-
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, write to the
- * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301 USA
- *
- * END_COMMON_COPYRIGHT_HEADER */
-
-
-#ifndef QTXDG_XDGMIME_H
-#define QTXDG_XDGMIME_H
-
-#include <QString>
-#include <QFileInfo>
-#include <QtGui/QIcon>
-
-#include "xdgmacros.h"
-
-struct XdgMimeData;
-
-/*! @brief The XdgMimeInfo class provides mime information about file.
- */
-class QTXDG_DEPRECATED QTXDG_API XdgMimeInfo
-{
-public:
-    /// Constructs a XdgMimeInfo with the mimeType type.
-    explicit XdgMimeInfo(const QString& mimeType);
-
-    /**
-    Constructs a new XdgMimeInfo that gives mime information about the given file.
-    If file is symlink and followSymLinks is true function gives information for the
-    file the link references rather than for the link itself.
-    **/
-    explicit XdgMimeInfo(const QFileInfo& file, bool followSymLinks=true);
-
-    ~XdgMimeInfo();
-
-    /// Returns the name of the mime type.
-    QString mimeType() const;
-
-    /// Returns the media type, eg. 'application' for mimetype 'application/pdf'
-    QString mediaType() const;
-
-    /// Returns the subtype, e.g. 'pdf' for 'application/pdf'
-    QString subType() const;
-
-    QString comment() const;
-
-    QString localizedComment() const;
-
-    QStringList patterns() const;
-
-    /// Returns an icon associated with the mime type.
-    QIcon   icon() const;
-
-    /// Returns an icon associated with the mime type.
-    QString iconName() const;
-
-    QString subClassOf() const;
-
-    bool loadFromDb(QIODevice* xml);
-
-private:
-    XdgMimeData *mData;
-};
-
-
-class QTXDG_DEPRECATED QTXDG_API XdgMimeInfoCache
-{
-public:
-    static QStringList mediatypes();
-    static QStringList subtypes(const QString & media);
-    static XdgMimeInfo* xdgMimeInfo(const QString & media, const QString & subtype);
-    static XdgMimeInfo* xdgMimeInfo(const QString & mimetype);
-
-private:
-    static QMap<QString, QMap<QString, XdgMimeInfo*> > & cache();
-};
-
-#endif // QTXDG_XDGMIME_H
-- 
1.9.0

